source ~/gef/gef.py

python
import re
import os
import subprocess
from time import sleep


class GetAllAddrClass(gdb.Command):
    def __init__(self):
        self.ex_delColor = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
        self.ex_finalAddr = re.compile(r'0x[0-9,a-z]*')
        self.cmd_setGdbTxtOn = "set logging on"
        self.cmd_setGdbTxtOff = "set logging off"
        super(GetAllAddrClass, self).__init__("getAllAddr", gdb.COMMAND_USER)
        self.dont_repeat()

    def invoke(self, arg, from_tty):
        argv = gdb.string_to_argv(arg)
        if len(argv) != 4:
            print("The function need [libcPath] [arch] [__libc_start_main_Got_offset] [gdbTool]")
            print("Such as getAllAddr /home/hacker/glibc/2.23/mips64el/lib/libc.so.6 mips64el 0x13128 pwndbg")
            return
        else:
            gdb.execute('rm gdb.txt')
            # 0:GEF 1:pwndbg
            dbgFlag = 0
            gdb.execute(self.cmd_setGdbTxtOn)
            libcFile = argv[0]
            arch = argv[1]
            libc_main_Got_offset = argv[2]
            gdbTool = argv[3]
            if (gdbTool == "pwndbg"):
                dbgFlag = 1
            elif (gdbTool == "gef"):
                dbgFlag = 0
            else:
                print("Can't support such gdb plugins!")
                return
            elf_addr, main_addr, libc_addr = self.getAllAddr(libcFile, libc_main_Got_offset, arch)
            print("elf_addr:" + elf_addr)
            print("main_addr:" + main_addr)
            print("libc_addr:" + libc_addr)
            with open('./addrAll.txt', "w+") as f:
                f.write("file_name:" + libcFile + '\n')
                f.write("elf_addr:" + elf_addr + '\n')
                f.write("main_addr:" + main_addr + '\n')
                f.write("libc_addr:" + libc_addr + '\n')
        gdb.execute('rm gdb.txt')
        if (dbgFlag == 0):
            gdb.execute('quit')
        else:
            return

    def getElfAddr(self, arch):
        cmd_vmmapElf = "vmmap stack"
        cmd_getMainElf = "p/x &main"
        ex_eflAddr = re.compile(r'0x[0-9,a-z]*\s*rw...*\[stack]\n')
        ex_mainAddr = re.compile(r'\$[0-9,a-z]*\s*=\s*[0-9,a-z]*')
        gdb.execute(self.cmd_setGdbTxtOn)
        gdb.execute(cmd_vmmapElf)
        gdb.execute(cmd_getMainElf)
        gdb.execute(self.cmd_setGdbTxtOff)
        sleep(0.5)
        with open('./gdb.txt', "rb+") as f:
            gdbStr = self.ex_delColor.sub('', bytes.decode(f.read()))
        f.close()
        elf_addr = self.ex_finalAddr.findall(ex_eflAddr.findall(gdbStr)[0])[0]
        main_offsetAddr = self.ex_finalAddr.findall(ex_mainAddr.findall(gdbStr)[0])[0]
        if (('mips64' in arch) or arch == 'aarch64'):
            elf_addr = '0x4000000000'
        return elf_addr, main_offsetAddr

    def getAllAddr(self, libcFile, libc_main_Got_offset, arch):
        arch64Offset = 0
        if (('mips64' in arch) or (arch == 'aarch64')):
            arch64Offset = 0x4000000000
        else:
            arch64Offset = 0
        __libc_start_main_offsetAddr = ""
        ex_libcAddr = re.compile(r'0x[0-9,a-z]*:\s*0x[0-9,a-z]*\n')
        elf_addr, main_offsetAddr = self.getElfAddr(arch)
        __libc_start_main_Got_addr = '0x{:0x}'.format(int(elf_addr, 16) + int(libc_main_Got_offset, 16))
        main_addr = '0x{:0x}'.format(int(elf_addr, 16) + int(main_offsetAddr, 16))
        cmd_breakMain = "b *({0})".format(main_addr)
        cmd_searchLibc = "x/wx {0}".format(__libc_start_main_Got_addr)
        gdb.execute(cmd_breakMain)
        gdb.execute("c")
        # gdb.execute("context")
        gdb.execute(self.cmd_setGdbTxtOn)
        gdb.execute(cmd_searchLibc)
        gdb.execute(self.cmd_setGdbTxtOff)
        with open('./gdb.txt', "rb+") as f:
            gdbStr = self.ex_delColor.sub('', bytes.decode(f.read()))
        f.close()
        # get binsh_offset in libc
        p = subprocess.Popen(["readelf", "-s", libcFile], stdout=subprocess.PIPE)
        for line in p.stdout.readlines():
            line = line.decode("utf-8").strip()
            if '__libc_start_main' in line:
                __libc_start_main_offsetAddr = '0x{:0x}'.format(int(line.split(' ')[1],16))
                break
        # print(gdbStr)
        # print(ex_libcAddr.findall(gdbStr)[0])
        __libc_start_main_addr = self.ex_finalAddr.findall(ex_libcAddr.findall(gdbStr)[0])[1]
        libc_addr = '0x{:0x}'.format(int(__libc_start_main_addr, 16) + arch64Offset - int(__libc_start_main_offsetAddr, 16))
        return elf_addr, main_addr, libc_addr
GetAllAddrClass()
end


python
import subprocess
import re


def relocatesections(filename, addr):
    p = subprocess.Popen(["readelf", "-S", filename], stdout=subprocess.PIPE)

    sections = []
    textaddr = '0'
    for line in p.stdout.readlines():
        line = line.decode("utf-8").strip()
        if not line.startswith('[') or line.startswith('[Nr]'):
            continue

        line = re.sub(r' +', ' ', line)
        line = re.sub(r'\[ *(\d+)\]', '\g<1>', line)
        fieldsvalue = line.split(' ')
        fieldsname = ['number', 'name', 'type', 'addr', 'offset', 'size', 'entsize', 'flags', 'link', 'info',
                      'addralign']
        sec = dict(zip(fieldsname, fieldsvalue))

        if sec['number'] == '0':
            continue

        sections.append(sec)

        if sec['name'] == '.text':
            textaddr = sec['addr']

    return (textaddr, sections)


class AddSymbolFileAll(gdb.Command):
    """The right version for add-symbol-file"""

    def __init__(self):
        self.ex_libcAddr = re.compile(r'libc_addr:[0-9,a-z]*')
        self.ex_fileName = re.compile(r'file_name:...*\n')
        self.ex_finalAddr = re.compile(r'0x[0-9,a-z]*')
        super(AddSymbolFileAll, self).__init__("add-symbol-file-all", gdb.COMMAND_USER)
        self.dont_repeat()

    def invoke(self, arg, from_tty):
        argv = gdb.string_to_argv(arg)
        # filename = argv[0]
        with open('./addrAll.txt', 'r+') as f:
            gdbStr = f.read()
        fileName = self.ex_fileName.findall(gdbStr)[0].strip("file_name:").strip('\n')
        libc_base = self.ex_finalAddr.findall(self.ex_libcAddr.findall(gdbStr)[0])[0]
        offset = int(str(gdb.parse_and_eval(libc_base)), 0)
        (textaddr, sections) = relocatesections(fileName, offset)

        cmd = "add-symbol-file %s 0x%08x" % (fileName, int(textaddr, 16) + offset)

        for s in sections:
            addr = int(s['addr'], 16)
            if s['name'] == '.text' or addr == 0:
                continue

            cmd += " -s %s 0x%08x" % (s['name'], addr + offset)
        gdb.execute(cmd)


class RemoveSymbolFileAll(gdb.Command):
    """The right version for remove-symbol-file"""

    def __init__(self):
        self.ex_libcAddr = re.compile(r'libc_addr:[0-9,a-z]*')
        self.ex_fileName = re.compile(r'file_name:...*\n')
        self.ex_finalAddr = re.compile(r'0x[0-9,a-z]*')
        super(RemoveSymbolFileAll, self).__init__("remove-symbol-file-all", gdb.COMMAND_USER)
        self.dont_repeat()

    def invoke(self, arg, from_tty):
        argv = gdb.string_to_argv(arg)
        # filename = argv[0]
        with open('./addrAll.txt', 'r+') as f:
            gdbStr = f.read()
        fileName = self.ex_fileName.findall(gdbStr)[0].strip("file_name:").strip('\n')
        libc_base = self.ex_finalAddr.findall(self.ex_libcAddr.findall(gdbStr)[0])[0]
        offset = int(str(gdb.parse_and_eval(libc_base)), 0)
        (textaddr, _) = relocatesections(fileName, offset)

        cmd = "remove-symbol-file -a 0x%08x" % (int(textaddr, 16) + offset)
        gdb.execute(cmd)


AddSymbolFileAll()
RemoveSymbolFileAll()
end



define hook-run
python
import angelheap
angelheap.init_angelheap()
end
end
